/* Autogenerated file. Do not edit manually. */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import { FunctionFragment, Result } from '@ethersproject/abi';
import { Provider } from '@ethersproject/providers';

export declare namespace Project {
  export type AmountStruct = { paid: BigNumberish; multiplied: BigNumberish };

  export type AmountStructOutput = [BigNumber, BigNumber] & {
    paid: BigNumber;
    multiplied: BigNumber;
  };

  export type CapStruct = { price: BigNumberish; index: BigNumberish };

  export type CapStructOutput = [BigNumber, BigNumber] & {
    price: BigNumber;
    index: BigNumber;
  };

  export type BidStruct = {
    amount: Project.AmountStruct;
    cap: Project.CapStruct;
    cancelable: boolean;
  };

  export type BidStructOutput = [
    Project.AmountStructOutput,
    Project.CapStructOutput,
    boolean,
  ] & {
    amount: Project.AmountStructOutput;
    cap: Project.CapStructOutput;
    cancelable: boolean;
  };
}

export interface LaunchpadInterface extends utils.Interface {
  contractName: 'Launchpad';
  functions: {
    'MAX_INT()': FunctionFragment;
    'USDC_DECIMAL()': FunctionFragment;
    'addBidding(uint256)': FunctionFragment;
    'bid(uint256,uint256,bool)': FunctionFragment;
    'bottomPrice()': FunctionFragment;
    'calcMultiplied(uint256,bool,bool)': FunctionFragment;
    'cancel()': FunctionFragment;
    'claimable(address)': FunctionFragment;
    'estimatedClaimable(uint256,bool,bool)': FunctionFragment;
    'findMinPriceCap()': FunctionFragment;
    'fixedRaised()': FunctionFragment;
    'owner()': FunctionFragment;
    'participant(address)': FunctionFragment;
    'price()': FunctionFragment;
    'priceBy(uint256)': FunctionFragment;
    'projectName()': FunctionFragment;
    'refund()': FunctionFragment;
    'refundable(address)': FunctionFragment;
    'saleEndTs()': FunctionFragment;
    'saleStartTs()': FunctionFragment;
    'tallied()': FunctionFragment;
    'tallyUp()': FunctionFragment;
    'tallyUpBetween(uint256)': FunctionFragment;
    'tokenDecimal()': FunctionFragment;
    'tokenTotalAlloc()': FunctionFragment;
    'totalMultiplied()': FunctionFragment;
    'update(uint256,uint256)': FunctionFragment;
    'updateCap(uint256)': FunctionFragment;
    'usdc()': FunctionFragment;
    'withdraw()': FunctionFragment;
    'withdrawable()': FunctionFragment;
  };

  encodeFunctionData(functionFragment: 'MAX_INT', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'USDC_DECIMAL',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'addBidding',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'bid',
    values: [BigNumberish, BigNumberish, boolean],
  ): string;
  encodeFunctionData(
    functionFragment: 'bottomPrice',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'calcMultiplied',
    values: [BigNumberish, boolean, boolean],
  ): string;
  encodeFunctionData(functionFragment: 'cancel', values?: undefined): string;
  encodeFunctionData(functionFragment: 'claimable', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'estimatedClaimable',
    values: [BigNumberish, boolean, boolean],
  ): string;
  encodeFunctionData(
    functionFragment: 'findMinPriceCap',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'fixedRaised',
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'participant', values: [string]): string;
  encodeFunctionData(functionFragment: 'price', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'priceBy',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'projectName',
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: 'refund', values?: undefined): string;
  encodeFunctionData(functionFragment: 'refundable', values: [string]): string;
  encodeFunctionData(functionFragment: 'saleEndTs', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'saleStartTs',
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: 'tallied', values?: undefined): string;
  encodeFunctionData(functionFragment: 'tallyUp', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'tallyUpBetween',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'tokenDecimal',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'tokenTotalAlloc',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'totalMultiplied',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'update',
    values: [BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateCap',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: 'usdc', values?: undefined): string;
  encodeFunctionData(functionFragment: 'withdraw', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'withdrawable',
    values?: undefined,
  ): string;

  decodeFunctionResult(functionFragment: 'MAX_INT', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'USDC_DECIMAL',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'addBidding', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bid', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'bottomPrice',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'calcMultiplied',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'cancel', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimable', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'estimatedClaimable',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'findMinPriceCap',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'fixedRaised',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'participant',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'price', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceBy', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'projectName',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'refund', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'refundable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'saleEndTs', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'saleStartTs',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'tallied', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'tallyUp', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'tallyUpBetween',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'tokenDecimal',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'tokenTotalAlloc',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'totalMultiplied',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'update', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateCap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'usdc', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'withdrawable',
    data: BytesLike,
  ): Result;

  events: {};
}

export interface Launchpad extends BaseContract {
  contractName: 'Launchpad';
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LaunchpadInterface;

  functions: {
    MAX_INT(overrides?: CallOverrides): Promise<[BigNumber]>;

    USDC_DECIMAL(overrides?: CallOverrides): Promise<[BigNumber]>;

    addBidding(
      newTotalPaid: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    bid(
      paid: BigNumberish,
      priceCap: BigNumberish,
      cancelable: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    bottomPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    calcMultiplied(
      paid: BigNumberish,
      hasCap: boolean,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { multiplied: BigNumber }>;

    cancel(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    claimable(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    estimatedClaimable(
      paid: BigNumberish,
      hasCap: boolean,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    findMinPriceCap(
      overrides?: CallOverrides,
    ): Promise<[string, BigNumber] & { sender: string; index: BigNumber }>;

    fixedRaised(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    participant(
      account: string,
      overrides?: CallOverrides,
    ): Promise<[Project.BidStructOutput]>;

    price(overrides?: CallOverrides): Promise<[BigNumber]>;

    priceBy(
      _totalMultiplied: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    projectName(overrides?: CallOverrides): Promise<[string]>;

    refund(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    refundable(
      account: string,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    saleEndTs(overrides?: CallOverrides): Promise<[BigNumber]>;

    saleStartTs(overrides?: CallOverrides): Promise<[BigNumber]>;

    tallied(overrides?: CallOverrides): Promise<[boolean]>;

    tallyUp(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    tallyUpBetween(
      count: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    tokenDecimal(overrides?: CallOverrides): Promise<[BigNumber]>;

    tokenTotalAlloc(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalMultiplied(overrides?: CallOverrides): Promise<[BigNumber]>;

    update(
      newTotalPaid: BigNumberish,
      priceCap: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    updateCap(
      priceCap: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    usdc(overrides?: CallOverrides): Promise<[string]>;

    withdraw(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    withdrawable(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  MAX_INT(overrides?: CallOverrides): Promise<BigNumber>;

  USDC_DECIMAL(overrides?: CallOverrides): Promise<BigNumber>;

  addBidding(
    newTotalPaid: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  bid(
    paid: BigNumberish,
    priceCap: BigNumberish,
    cancelable: boolean,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  bottomPrice(overrides?: CallOverrides): Promise<BigNumber>;

  calcMultiplied(
    paid: BigNumberish,
    hasCap: boolean,
    cancelable: boolean,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  cancel(
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  claimable(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  estimatedClaimable(
    paid: BigNumberish,
    hasCap: boolean,
    cancelable: boolean,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  findMinPriceCap(
    overrides?: CallOverrides,
  ): Promise<[string, BigNumber] & { sender: string; index: BigNumber }>;

  fixedRaised(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  participant(
    account: string,
    overrides?: CallOverrides,
  ): Promise<Project.BidStructOutput>;

  price(overrides?: CallOverrides): Promise<BigNumber>;

  priceBy(
    _totalMultiplied: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  projectName(overrides?: CallOverrides): Promise<string>;

  refund(
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  refundable(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  saleEndTs(overrides?: CallOverrides): Promise<BigNumber>;

  saleStartTs(overrides?: CallOverrides): Promise<BigNumber>;

  tallied(overrides?: CallOverrides): Promise<boolean>;

  tallyUp(
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  tallyUpBetween(
    count: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  tokenDecimal(overrides?: CallOverrides): Promise<BigNumber>;

  tokenTotalAlloc(overrides?: CallOverrides): Promise<BigNumber>;

  totalMultiplied(overrides?: CallOverrides): Promise<BigNumber>;

  update(
    newTotalPaid: BigNumberish,
    priceCap: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  updateCap(
    priceCap: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  usdc(overrides?: CallOverrides): Promise<string>;

  withdraw(
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  withdrawable(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    MAX_INT(overrides?: CallOverrides): Promise<BigNumber>;

    USDC_DECIMAL(overrides?: CallOverrides): Promise<BigNumber>;

    addBidding(
      newTotalPaid: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    bid(
      paid: BigNumberish,
      priceCap: BigNumberish,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<void>;

    bottomPrice(overrides?: CallOverrides): Promise<BigNumber>;

    calcMultiplied(
      paid: BigNumberish,
      hasCap: boolean,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cancel(overrides?: CallOverrides): Promise<void>;

    claimable(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    estimatedClaimable(
      paid: BigNumberish,
      hasCap: boolean,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    findMinPriceCap(
      overrides?: CallOverrides,
    ): Promise<[string, BigNumber] & { sender: string; index: BigNumber }>;

    fixedRaised(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    participant(
      account: string,
      overrides?: CallOverrides,
    ): Promise<Project.BidStructOutput>;

    price(overrides?: CallOverrides): Promise<BigNumber>;

    priceBy(
      _totalMultiplied: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    projectName(overrides?: CallOverrides): Promise<string>;

    refund(overrides?: CallOverrides): Promise<void>;

    refundable(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    saleEndTs(overrides?: CallOverrides): Promise<BigNumber>;

    saleStartTs(overrides?: CallOverrides): Promise<BigNumber>;

    tallied(overrides?: CallOverrides): Promise<boolean>;

    tallyUp(overrides?: CallOverrides): Promise<void>;

    tallyUpBetween(
      count: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    tokenDecimal(overrides?: CallOverrides): Promise<BigNumber>;

    tokenTotalAlloc(overrides?: CallOverrides): Promise<BigNumber>;

    totalMultiplied(overrides?: CallOverrides): Promise<BigNumber>;

    update(
      newTotalPaid: BigNumberish,
      priceCap: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    updateCap(priceCap: BigNumberish, overrides?: CallOverrides): Promise<void>;

    usdc(overrides?: CallOverrides): Promise<string>;

    withdraw(overrides?: CallOverrides): Promise<void>;

    withdrawable(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    MAX_INT(overrides?: CallOverrides): Promise<BigNumber>;

    USDC_DECIMAL(overrides?: CallOverrides): Promise<BigNumber>;

    addBidding(
      newTotalPaid: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    bid(
      paid: BigNumberish,
      priceCap: BigNumberish,
      cancelable: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    bottomPrice(overrides?: CallOverrides): Promise<BigNumber>;

    calcMultiplied(
      paid: BigNumberish,
      hasCap: boolean,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    cancel(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    claimable(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    estimatedClaimable(
      paid: BigNumberish,
      hasCap: boolean,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    findMinPriceCap(overrides?: CallOverrides): Promise<BigNumber>;

    fixedRaised(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    participant(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    price(overrides?: CallOverrides): Promise<BigNumber>;

    priceBy(
      _totalMultiplied: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    projectName(overrides?: CallOverrides): Promise<BigNumber>;

    refund(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    refundable(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    saleEndTs(overrides?: CallOverrides): Promise<BigNumber>;

    saleStartTs(overrides?: CallOverrides): Promise<BigNumber>;

    tallied(overrides?: CallOverrides): Promise<BigNumber>;

    tallyUp(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    tallyUpBetween(
      count: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    tokenDecimal(overrides?: CallOverrides): Promise<BigNumber>;

    tokenTotalAlloc(overrides?: CallOverrides): Promise<BigNumber>;

    totalMultiplied(overrides?: CallOverrides): Promise<BigNumber>;

    update(
      newTotalPaid: BigNumberish,
      priceCap: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    updateCap(
      priceCap: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    usdc(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    withdrawable(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    MAX_INT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    USDC_DECIMAL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addBidding(
      newTotalPaid: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    bid(
      paid: BigNumberish,
      priceCap: BigNumberish,
      cancelable: boolean,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    bottomPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    calcMultiplied(
      paid: BigNumberish,
      hasCap: boolean,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    cancel(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    claimable(
      account: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    estimatedClaimable(
      paid: BigNumberish,
      hasCap: boolean,
      cancelable: boolean,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    findMinPriceCap(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fixedRaised(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    participant(
      account: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    price(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceBy(
      _totalMultiplied: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    projectName(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    refund(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    refundable(
      account: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    saleEndTs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    saleStartTs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tallied(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tallyUp(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    tallyUpBetween(
      count: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    tokenDecimal(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenTotalAlloc(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalMultiplied(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    update(
      newTotalPaid: BigNumberish,
      priceCap: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    updateCap(
      priceCap: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    usdc(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    withdrawable(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
